<resources xmlns:tools="http://schemas.android.com/tools">
    <string name="app_name">My Application</string>
    <string name="title_activity_scrolling">ScrollingActivity</string>
    <string name="large_text">
       Программирование занимает одну из значительных ниш в современном мире. Это не просто способ заставить работать «железяки», но и поставить себя на путь развития своих способностей. Но, прежде чем мы разберём все полезные свойства, следовало бы разобраться с терминологией. Программирование — область деятельности, направленная на разработку программного обеспечения, которое, в свою очередь, направлено на улучшение и облегчение человеческого быта, промышленной деятельности, сферы услуг и технологического прогресса.

Одним из детей программирования можно назвать сервис виртуальный номер для смс. Благодаря ему вы можете отправлять, получать, осуществлять массовую рассылку смс даже без наличия телефона. Аналогично виртуальному номеру телефона существует и факс-номер. Вы можете купить себе для офиса эту услугу и получать факс, например, на электронную почту.

Что касается пользы в изучении и тренировки навыков программирования, то можно смело сказать, что этот род деятельности не только приносит хороший заработок, но и неплохо развивает мышление и логику. Как и любая точная наука, программирование развивает аналитические и дедуктивные способности, абстрактное мышление. Можно смело сказать, что эта отрасль дает развитие человека в целом. Навыки создания программ, позволят обрести такие качества как упорядоченность мыслей, строгая организация и постановка решения проблем практически любого уровня сложности и характера.

Существует множество примеров успешных людей, которые достигли высот профессиональной деятельности, которые никак не связана с программированием, именно благодаря тому, что в своё время имели некоторую практику написания кода в колледжах и университетах.

Нынешнее программирование многогранно и используется в таких важных сферах как строительство, бизнес и экономика, медицина, биология и физика. Большой процент физического труда в промышленности заменен на машинный и роботизированный труд, который управляется посредством программного обеспечения, что обеспечивает существенный прирост скорости, точности операций и эффективности производства. Такое богатство разнообразия применений обеспечивается солидным выбором языков программирования, у каждого из которых есть свои плюсы и минусы.

Только представьте, сколько пользы приносит программирование в наши дни, ведь использование в множестве развивающихся направлений науки и инфраструктуры, это далеко не всё. Как известно, программирование — это тяжелый умственный труд, а труд сделал из обезьяны человека. В условиях нашего, быстроразвивающегося мира, именно умственный труд определяет место человека в обществе.

В заключение можно сказать, что саморазвитие очень важно для достижения новых высот, а программирование является очень приятным, удобным, а главное — эффективным способом саморазвития.
    </string>
    <string name="text1">

        1. Ваша первая программа
         Среда программирования
Для того чтобы увидеть результат программы, пусть даже самой простой, нужно:

написать программу. Для этого нужно владеть языком программирования, причем знать не только синтаксис, но и возможности так называемых библиотек, уметь пользоваться текстовым редактором, при необходимости установить его, сохранить файл на диске;
скомпилировать. Процессор понимает только машинные команды, поэтому нужно перевести текст программы в числовые коды. Это не всегда происходит сразу после написания кода. Во многих языках программирования окончательная компиляция происходит уже в процессе выполнения программы;
в случае, если программа разрабатывается для другого устройства, загрузить откомпилированный (или частично откомпилированный код) на устройство. Для этого нужно связаться с устройством, использовать протоколы передачи информации;
запустить программу на выполнение.
Для того чтобы на хорошем уровне понимать детали этого процесса, нужно учиться не один год. И тем не менее, мы напишем, скомпилируем, загрузим и запустим первую программу уже на этом занятии. Как это возможно? Существует много средств для облегчения труда разработчиков. При этом нужно постоянно осознавать, что нужно понимать, как «оно устроено внутри». Мы будем возвращаться и рассматривать детали постепенно.

Прежде всего, главный инструмент разработчика — это среда программирования (еще называют «среда разработки»). Для эффективной работы необходимо хорошо представлять ее возможности и постоянно пользоваться ими.

Обычно среда разработки содержит несколько компонентов.

Редактор кода. Главное преимущество редактора среды программирования перед обычным редактором, например, Блокнотом в Windows — в подсветке синтаксиса — ключевые слова выделяются цветом.

Компилятор. Среда может ставиться и без компилятора и работать с различными компиляторами, установленными на компьютере, но в любом случае она делает процесс компиляции «прозрачным» для программиста. Например, среда Eclipse по умолчанию настроена так, что компиляция и запуск программ объединены в одной команде (делаются одной кнопкой).

Средства запуска. Eclipse c установленным плагином ADT (Android Developers Tools) и Android Studio позволяет запускать программы сразу на устройстве или эмуляторе.

Отладчик. Для того чтобы разобраться в том, почему программа работает не так, как задумывал разработчик, можно не только пристально смотреть в код, но и выполнить программу по шагам, чтобы посмотреть промежуточные результаты работы и понять, правильно ли ведет себя программа. Все это делает отладчик. Без отладчика, как и без среды программирования, можно обойтись, но грамотное его использование серьезно облегчает работу.

Заходим в приложение IntelliJ IDEA и создаем ваш первый проект. Панель слева называется Навигатор. В навигаторе отображаются структура и файлы проекта. На рисунке выше в Навигаторе открыт проект First, в нем Java-файл Program1.

Сразу приведем текст программы и прокомментируем важные части кода. Обучение программированию по примерам — частый и хороший прием, но при этом надо стараться понимать все, что написано, каждую строчку.

Двумя слешами (//) начинаются комментарии — это текст, который компилятор игнорирует, а мы будем его использовать для объяснения важных моментов прямо в коде. Генератор сам вставляет в создаваемый код комментарий.
        Полный текст программы:



public class Program1 {

    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
        Программа «Hello, world» на Java замечательна тем, что на ее примере можно обсудить многие особенности программирования на этом языке.

Все слова, кроме текста в кавычках, требуют осмысления. Прежде всего, программа на Java — это класс или несколько классов. Для простейшей программы достаточно одного класса, но он использует класс System , библиотечный, стандартный класс, который устанавливается вместе с компилятором Java.
        Запускаем программу нажав заеный треугольник в вверхнем углу приложеения. И все, ваша первая программа написанна. Поздраляю!
    </string>

    <string name="text2">
 2.Объявление переменных

Первые электронно-вычислительные машины создавались для того, чтобы производить сложные вычисления. Сейчас компьютеры используют в самых различных областях. Это и просмотр видео, и компьютерные игры, и обработка звука. Однако в основе работы компьютеров по-прежнему остаются именно вычисления. Изображение и звук появляются благодаря размещению чисел в ячейках памяти звуковой и видеокарты. 3D-эффект в играх — это результат обработки чисел алгоритмами вычислительной геометрии и так далее.

Отдельным типом данных можно (а в Java нужно) считать строки, но даже строки для компьютера — это на самом деле последовательности чисел — кодов символов. Например, в языке Си практически нет разницы между числами и символами, она проявляется в основном только при выводе. Поэтому очень важно понимать, как устроена в языке работа с числами.

Все типы данных в Java разделяются на два класса — примитивные и ссылки на объекты. На этом занятии мы будем рассматривать в основном только числовые примитивные типы.

Обычно алгоритм получает данные, размещает их в своей памяти, обрабатывает и возвращает результат. Функция main главного класса имеет тип void, то есть фактически ничего не возвращает, но мы все равно получаем результат, используя вывод.

Соответственно, для того чтобы написать минимально полезную программу, нужно знать, как организовать ячейки памяти для хранения данных, заводить так называемые переменные и выполнять вычисления с ними, вводить и выводить значения переменных (в простейшем случае с консоли и на консоль).


Это так называемый псевдокод. В реальных программах слова в угловых скобках и сами угловые скобки не пишутся, а вместо них употребляются соответствующие конструкции языка. Квадратные скобки также не пишутся. Они означают, что данная часть кода не обязательна. Например, в программе создание переменной может выглядеть так:

int a2;
или так:

double xx = .15;
(дробные числа в коде записываются через точку, при этом нулевая целая часть может опускаться).

Переменные могут называться любой последовательностью латинских букв, цифр и знаков подчеркивания, при этом не могут начинаться с цифры. Лучше всего в программах давать переменным «говорящие» имена. Например, переменную, в которой хранится ширина, стоит называть width. Старайтесь использовать именно английские названия. Транслит в программах выглядит плохо.

Основные числовые типы — int — целые числа и double — вещественные. Вывод чисел выполняется так же, как и строк, при помощи PrintStream, например

int x = 5, y = 7;
System.out.println(x + y);
выведет 12.

Для ввода переменных удобно использовать класс Scanner, вернее объект класса Scanner.

Scanner in = new Scanner(System.in);
Для ввода целых чисел нужно использовать функцию класса Scanner nextInt(), например

int x = in.nextInt();
Для чтения вещественных чисел можно использовать функцию nextDouble(), но перед ее использованием нужно настроить Scanner на использование десятичной точки (а не запятой по обычному умолчанию), например, вот так:

in.useLocale(Locale.US);
Это нужно сделать всего один раз, лучше в самом начале функции main. Вывод вещественных чисел происходит как обычно.

Чтобы посчитать площадь круга с данным нецелым радиусом, можно написать:

in.useLocale(Locale.US);
//…
double r = in.nextDouble();
System.out.println(3.1415 * r * r);
При вводе вещественных чисел дробную часть после точки можно опускать. То есть будет восприниматься корректно как 35,0 так и просто 35. (с точкой).

У вещественных чисел нет жестких ограничений на величину, как у типа int, но при работе с ними возникает погрешность, поэтому нужно быть осторожным.

Заметим, что при использовании Scanner могут возникать исключения. Если ввести некорректные данные, например, 14..a5, то программа закончится аварийно, потому что Scanner не сможет найти число в переданной ему информации. Этой ситуации можно избежать. В реальной программе следует перехватить исключение и вместо аварийного завершения программы сообщить пользователю о его ошибке и попросить ввести число еще раз.

    </string>
    <string name="text3">

 3. Автоматическое тестирование
Когда программа достаточно сложна, проверить ее правильность «глазами» очень затруднительно. Обычно в этом случае прибегают к автоматическому тестированию.

Мы знаем, как должна вести себя программа, если ей ввести определенные данные. Например, наша программа должна выдать 12, если ей сообщить 5 и 7.

В большинстве случаев для проверки достаточно сравнить полученные данные с эталонными. Эту проверку несложно поручить программе.

Например, на олимпиадах по программированию проверка осуществляется именно так. Участник посылает текст решения в систему, она компилирует его, запускает на наборе тестов и выдает вердикт.

Одним из ведущих сайтов в области школьной олимпиадной информатики в России является http://informatics.msk.ru/. Им очень удобно пользоваться для проверки своих решений по построению алгоритмов. Для полноценной работы с сайтом нужно зарегистрироваться по ссылке в правом верхнем углу страницы. После этого в правой колонке можно указать номер задачи.

Задачи курса можно решать как на сайте http://informatics.msk.ru/, так и прямо в курсе, в IT ШКОЛЕ SAMSUNG используется собственная тестирующая система.

Задача «A + B» (номер 111642 на http://informatics.msk.ru/)

Обратим внимание на ее условие.

Входные данные:

На первой строке входного файла находятся два целых числа a и b (−10⁹≤a, b≤ 10⁹).

Выходные данные:

Вашей программе требуется вывести единственное число — сумму заданных чисел a + b.

Условие в скобках писать в программу не нужно. Это так называемое ограничение входных данных. Оно говорит, что программа должна корректно работать, если введенные данные соответствуют этому условию. При этом программа может как угодно работать или даже аварийно завершаться, если входные данные ему не соответствуют. Если «пользователь» введет дробные числа или, например, три числа или даже свое ФИО, программа может вести себя любым образом.

В подобных задачах входные данные всегда корректны, то есть точно соответствуют условию и примерам. Это очень важное правило. Оно дает возможность участнику сосредоточится именно на разработке алгоритма, а не строить вместо этого совершенную «защиту от дурака», что, наоборот, абсолютно необходимо делать при разработке прикладных программ.

Программа не должна выводить лишнего. Это будет расценено системой как неверный ответ. Нужно убрать из программы строки с выводом приглашения и строки «Сумма:».

Перед посылкой надо проверить на тестах из условия.

2+3 получается 5.
17–8 выводится –1.
Технически система требует, чтобы программа была в одном файле, в пакете по умолчанию. Поэтому строки package в коде быть не должно.



    </string>
    <string name="text4">

 4. Арифметические операции
       С вычислениями в Java все достаточно стандартно. Можно использовать четыре арифметические операции (умножение записывается звездочкой (*), а деление прямым слешем (/)).

Приоритеты операций стандартны.

Но при программировании на языке Java нужно быть очень внимательным, учитывать особенности арифметических операций.

Арифметические операции могут вызвать переполнение.

Целые числа в Java (переменные типа int) не могут содержать значения большие 231 по модулю. Это чуть больше двух миллиардов. Когда результат операции превышает этот предел, возникает переполнение — ответ становится неверным.

Обязательно посмотрите, что выведет фрагмент:

int x = 1000 * 1000;
System.out.println(x * x);
Деление целых чисел выполняется нацело.

Например, результат 5 / 3 равен 1.

Операция процент (%) позволяет вычислить остаток от деления. Например, 5 % 3 это 2. С отрицательными числами остаток от деления работает не так, как подсказывает интуиция. Проверьте, что выведет строка:

out.println((-7) % 3);
и поймите, почему получается именно такой результат.

Операция взятия остатка очень часто используется в программировании. Например, проверку четности числа удобно делать так:

/*сравнение в Java выполняется удвоенным знаком равенства (==)*/
if (a % 2 == 0) …
Операция % применима в Java не только к целым числам. Проверьте, что выведет команда

System.out.println((12.72) % 3);
В Java нет операции возведения в степень!

Крышечка (^) работает не как степень (в Java это логическая поразрядная операция).

Чтобы операция деления производилась без отсечения дробной части (обычное деление, не нацело) нужно, чтобы одно из чисел было нецелым (либо вещественной константой, либо переменной нецелого типа). Например, если

int a = 7, b = 8;
тогда команда

System.out.println((a + b) / 2);
выведет 7, а команда

System.out.println((a + b) / 2.0);
выведет 7.5.

    </string>

    <string name="text5">
 5.Операции с присваиванием
Чтобы изменить переменную, например, получить показания часов через минуту, обычно пишут примерно такой код:

minutes = minutes + 1;
Однако в Java есть более удобные средства. Можно записать:

minutes += 1;
Существуют комбинированные операции с равенством со всеми основными операциями. То есть возможно использовать -= /= %= и так далее. Нужно стараться использовать именно эти операции. Они выполняются быстрее, это понятнее и проще читается. Если увеличение или уменьшение должно быть именно на 1, то можно использовать операции ++ (инкремент) и — (декремент), например

minutes++;
 6.Обзор примитивных типов данных
Данные примитивных типов представляются фиксированным количеством двоичных разрядов.

Это очень важно, потому что задает ограничение на размер чисел. Например, если использовать всего три двоичных разряда, можно применять только 8 различных значений: 000, 001, 010, 011, 100, 101, 110 и 111. То есть представлять 8 различных чисел. В реальных типах используется значительно больше разрядов.

Целочисленные типы в Java
Название	Длина (байт/бит)	Область значений
byte	1 (8)	-128 .. 127
short	2 (16)	-32.768 .. 32.767
char	2 (16)	 .. , или 0 .. 65.535
int	4 (32)	–2.147.483.648 .. 2.147.483.647
long	8 (64)	-9.223.372.036.854.775.808 .. 9.223.372.036.854.775.807 (примерно 1019)
Особое место среди числовых типов занимает тип char. С одной стороны, это «обычный» числовой тип в том смысле, что можно со значениями этого типа делать арифметические действия. Это беззнаковый тип, отрицательных значений этого типа не существует. С другой стороны, этот тип используется для представления символов. Java использует unicode — шестнадцатибитное представление символов.

В Java можно использовать константы в шестнадцатеричном виде, если начинать их с префикса 0x. Например, 0xB — это одиннадцать. Это очень часто используется, например, в генерации R — основного файла ресурсов Android-приложения.


   7.Приведение примитивных типов
        Если в выражении участвуют операнды разных типов, происходит их приведение. Приведение в бо́льшую сторону происходит автоматически, в меньшую нужно делать вручную.

Можно написать

double z = 5;
Целое 5 при присваивании будет преобразовано в double, а вот

int x = 3 / 1.5; //НЕВЕРНО!
не скомпилируется, нужно приводить типы явно:

int x = (int)(3 / 1.5);
Правильно возвести 100 миллионов в квадрат можно так:

int x = 100 * 1000 * 1000;
System.out.println((long)x * x);
Достаточно при этом привести к типу long один из множителей.


    8.Логические выражения
С логическими операторами программисты работают значительно чаще, чем с поразрядными. Это связано с тем, что в Java из них строятся логические выражения, повсеместно использующиеся в операторах ветвления и цикла, которые будут рассмотрены в следующих темах.

Результат ИСТИНА, если оба операнда ИСТИНА, в остальных случаях — ЛОЖЬ.

|| ИЛИ (дизъюнкция или логическое сложение)

Результат ЛОЖЬ, если оба операнда ЛОЖЬ, в остальных случаях — ИСТИНА.

! НЕ (отрицание)

Унарная операция. Если операнд ИСТИНА, то результат — ЛОЖЬ, и наоборот.

Приоритет операций
Чтобы правильно использовать несколько логических операторов в одном выражении, нужно учитывать приоритет операций, который и определяет порядок вычисления результата логического выражения.

Среди логических операций наибольший приоритет у операции !, наименьший приоритет имеет операция ||.

В выражениях, где встречаются операторы разных типов, сначала выполняются арифметические операции, затем операции сравнения, затем логические операции и в последнюю очередь присваивание.

В Java нельзя выстраивать цепочки операций сравнения — это строго бинарные операции. Это значит, что двойные условия типа 1≤x≤6 записываются в виде пар логических операций. Для этого нужно разделить такое сложное условие двумя простыми



      9.Тип boolean
Для хранения логических величин в Java имеется специальный тип boolean. Размер типа boolean зависит от виртуальной машины.

Из официальной документации: «This data type represents one bit of information, but its „size“ isn’t something that’s precisely defined».1

То есть размер типа boolean зависит только от реализации JVM. Чаще всего размер совпадает с машинным словом (32 или 64 бита). Но если завести массив из boolean, то каждый элемент будет занимать 1 byte.2

Вообще можно было бы реализовать тип boolean всего при помощи одного бита, но это сделано для производительности.

Дело в том, что «байт» — это минимальная единица адресации в компьютерной памяти. Для того чтобы работать с отдельными битами, используют поразрядные операции, которые применяются ко всем битам байта. Окончательные сравнения происходят, естественно, тоже в целых байтах.

Переменные типа boolean могут принимать всего два специальных значения true и false (ИСТИНА и ЛОЖЬ). Значения этого типа можно сравнивать на равенство и производить с ними логические операции, но с ними нельзя производить арифметические вычисления.
Переменная b2 принимает значение true, потому что первый и второй операнды конъюнкции истинны.


</string>
    <string name="text12">
        10. Конструкция if/else


Условный оператор if проверяет истинность выражения. Если проверка выражения покажет, что оно истинно (возвращается значение true), то выполняются действия после условия, в противном случае (возвращается значение false) выполняются команды после else.

Например, так в языке Java можно получить максимальное из двух чисел

if (а > b){
    max = a;
}
else {
    max = b;
}
После ключевого слова if следует условие в круглых скобках. Как и во многих других языках условие может быть реализовано:

1. В полной форме:

// Псевдокод
if (условие) Действия 1
else Действия 2
2. В краткой форме:

// Псевдокод
if (условие) Действия 1
В первом случае при выполнении условия происходит выполнение Действий 1, при невыполнении условия — Действия 2. Во втором случае при выполнении условия происходит выполнение Действий 1, при невыполнении условия происходит выполнение следующей, после условного оператора, строки команд.

Условные выражения
Выражение, проверяемое в условном операторе, может быть простым, а может быть составным.



        11.Конструкция switch/case
Оператор выбора switch/case позволяет сделать выбор между несколькими вариантами.

// Псевдокод
switch(выражение) {
    case значение 1: команды 1
    case значение 2: команды 2
    …
    case значение N: команды N
    default: команды N+1
}
Оператор switch/case работает так:

вычисляется значение выражения;
если такое значение найдено, то дальнейшая проверка не производится, а выполняются команды, начинающиеся с выбранной ветви и далее по коду. Если подходящего значения в перечне нет, то выполняются команды, стоящие после ключевого слова default. Если ветви default нет, то не выполняется ничего. В конструкции switch может быть применен только один оператор default. Поэтому обычно каждый case заканчивается break.
// Псевдокод
switch(выражение) {
    case значение 1: команды 1
                    break;
    case значение 2: команды 2
                    break;
    …
    case значение N: команды N
                    break;
    default: команды N+1
}
В этом случае программа работает интуитивно понятно. Выполняются только команды из одной ветви.

Однако бывают случаи, когда break; не ставят принципиально.



        12.Конструкция while
Когда в России в восьмидесятых годах только появились персональные компьютеры, практически каждый школьник, счастливый обладатель электронного чуда,сразу  писал программу на встроенном в ПЗУ Basic’е:

10 PRINT "I’M A COOL PROGRAMMER"
20 GOTO 10
Те времена прошли. В языке Java оператора goto вообще нет. Более того, разработчики языка иронично оставили это слово в списке ключевых слов, так чтобы его практически никак нельзя было использовать в программах. Действительно, оператор безусловного перехода сильно портит читаемость программы. Для того чтобы «заставить» компьютер повторять последовательность действий, нужно использовать циклы.

В четвертом модуле рассматривается использование рекурсии для организации повторений.

Цикл в программе организовать просто. По структуре он очень похож на if.

//ПСЕВДОКОД
while (условие){

Действия (выполняются пока условие истинно)

}


Слово while в переводе с английского значит «до тех пор», «пока». Программа будет выполнять команды до тех пор, пока условие истинно. Проверяется условие, если оно истинно, выполняются команды, и программа переходит опять на проверку условия.

Блок команд, расположенных после while, называют телом цикла. Так же как и в условном операторе тело цикла может представлять из себя один оператор либо блок операторов (см. тему «1.5. Логические выражения»).

Обратите внимание, как и в if точка с запятой после условия в скобках не ставится!



Таким образом, команды могут не выполниться ни разу (если условие сразу ложно) или выполняться сколько угодно раз. Естественно, предусматривают остановку этого процесса. Обычно условие зависит от значения переменной, а эта переменная изменяется командами. Например, цикл в реальной программе может выглядеть так:

int x = 0;
while (x меньше 5){
    оut.print(x + " ");
    x++;
}
Сколько эта программа напечатает чисел?

Что напечатает строка,

оut.print("x = " + x);
если добавить ее после закрывающей фигурной скобки?

Значение переменной x будет равно 5 после цикла, именно при этом сравнение, которое проверяет цикл станет ложным. Поэтому будет выведена строка: x = 5.

Условия, как и в if, могут быть абсолютно любыми логическими выражениями, например, содержать логические операции ||.





        13. Конструкция do while
Рассмотренный цикл while часто называют циклом с предусловием, потому что условие продолжения цикла стоит на входе в него. То есть такой цикл всегда сначала проверяет условие и потом выполняет тело, а следовательно, вполне возможна ситуация, когда тело цикла не будет выполнено ни разу.

Если необходимо, чтобы тело цикла было выполнено хотя бы один раз в любом случае, то удобнее пользоваться циклами с постусловием. То есть таким циклом, в котором сначала выполняется тело цикла, а потом проверяется условие его продолжения и перехода на следующий шаг. В Java цикл с постусловием реализуется с помощью оператора do while.

//ПСЕВДОКОД do { Действия //(выполняются пока условие истинно) } while (условие); // точка с запятой НУЖНА!

Обратите внимание, что после условия while ставится точка с запятой. Во всем остальном (оформление тела цикла, условия) синтаксис оператора аналогичен while. Давайте реализуем предыдущий пример через цикл do while, просто переместив условие while в конец, согласно синтаксису do while:

int x = 0;
do {
    оut.print(x + " ");
    x++;
} while (x меньше 5);
Будет выведено

0 1 2 3 4

Значение переменной x после выполнения цикла будет также равно 5.

</string>
    <string name="title_activity_main4">MainActivity</string>
    <string name="navigation_drawer_open">Open navigation drawer</string>
    <string name="navigation_drawer_close">Close navigation drawer</string>
    <string name="nav_header_title">Android Studio</string>
    <string name="nav_header_subtitle">android.studio@android.com</string>
    <string name="nav_header_desc">Navigation header</string>
    <string name="action_settings">Settings</string>

    <string name="menu_home">Home</string>
    <string name="menu_gallery">Gallery</string>
    <string name="menu_slideshow">Slideshow</string>

    14. Оператор break
    В языке Java есть способ выйти из цикла досрочно, без учета условия в while, — оператор break.
    Например, программа

    int x = 10;
    while (x меньше 100){
    if (x == 2 * (x / 10) * (x % 10)){
    break;
    }
    x++;
    }
    выйдет из цикла, когда найдет первое двузначное число, равное удвоенному произведению своих
    цифр.

    Не стоит злоупотреблять досрочным выходом из цикла. Можно, конечно, написать так:

    int i = 1;
    while(true){
    out.println (i);
    i++;
    if (i == 10) break;
    }
    Но значительно лучше читается простое и естественное

    while(i меньше равно 10)
    без использования break. Такой вариант делает программу более понятной.

    Следует учитывать, что break прерывает именно цикл. Но использовать его, конечно, стоит только в
    условном операторе, который находится в цикле.


    15.Конструкция for
    Для того чтобы организовать цикл в программе, можно использовать конструкцию while, которая
    очень похожа на if.

    Но не все так просто. В отличие от if при использовании while необходимо правильно организовать
    выход. Это можно организовать оператором break, но это именно «аварийный выход».

    «Обычный» while в программе выглядит примерно так:

    i = 0; // инициализация счетчика
    while (i меньше N){ //условие цикла

    //... тело цикла - действия, которые выполняются многократно
    i++; //приращение счетчика
    }

    Все эти строки очень важны.

    Конечно, никто не забывает написать в программе условие цикла. Но начальную инициализацию и
    приращение счетчика очень легко забыть написать. И от этого цикл «зависает» или наоборот не
    выполняется ни разу.

    В конструкции for все действия, кроме собственно команд, собраны в одной строке.

    В конструкции for, как и в конструкции while, «ненужные» вещи можно опускать. Например, для того
    чтобы вычислить степень тройки, ближайшую к миллиону справа (минимальную, но превосходящую
    миллион), можно написать:

    p = 1;
    for (; p меньше равно 1000000; ){
    p *= 3;
    }
    При этом две точки с запятой должны остаться в любом случае. Впрочем, этот код лучше переписать
    так:

    for (p = 1; p меньше равно 1000000; p *= 3){
    }
    Оператор break работает в for точно так же, как и в while.

    Счетчик цикла можно объявлять в самой строке for. В этом случае объявленная переменная будет
    существовать только внутри цикла. Например, программу, выводящую столбик чисел от 10 до 1, можно
    написать так:

    for (int i = 10; i > 0; i--){
    out.println(i);
    }
    Если команду вывода вызвать еще раз после цикла,

    for (int i = 10; i > 0; i--){
    out.println(i);
    }
    out.println(i); // ОШИБКА! Переменная i здесь не существует
    то программа не скомпилируется: после цикла переменная i не существует.

    Особенно повышается читаемость программы при использовании for вместо while при организации
    вложенных циклов («один в другом»). Например, если надо вывести квадрат из N звездочек, можно
    написать так:

    for (int i = 0; i меньше N; i++)
    {
    for (int j = 0; j меньше N; j++)
    {
    out.print("*");
    }
    out.println();
    }
    Обратите внимание: в циклах — разные переменные-счетчики!


    16.Оператор continue
    Иногда полезно начать очередную итерацию цикла раньше. То есть нужно продолжить выполнение
    цикла, но прекратить обработку остатка кода в его теле для данной итерации. Такое действие
    выполняет оператор continue.

    Можно рассматривать его как goto-переход мимо следующих операций тела в конец блока цикла. В
    циклах while и do while оператор continue вызывает передачу управления непосредственно условному
    выражению, которое управляет циклом. В цикле for управление переходит сначала к итерационной
    части оператора for (третье выражение, после второй точки с запятой, в которой выполняется
    изменение счетчика) и затем к условному выражению.


    Оператор continue удобно использовать, когда нужно обработать все данные кроме некоторых. Тогда
    его ставят в начале цикла. Это помогает избежать использования дополнительного if, а значит
    избавиться от еще одного уровня вложенности.

    Например, фрагмент программы, проверяющей клетки, которые бьет шахматный конь, могут выглядеть
    так:

    // x, y - координаты шахматного коня
    for (int dx = -2; dx меньше равно 2; dx++) {
    for (int dy = -2; dy меньше равно 2; dy++) {
    // если клетку конь не бьет - она нам не интересна
    if ( Math.abs(dx * dy) != 2) continue;
    // Обработка клетки x + dx, y + dy - координаты клетки, которую бьет конь
    // ...
    }
    }
    Можно записать это и без continue, но тогда появится лишний отступ

    for (int dx = -2; dx меньше равно 2; dx++) {
    for (int dy = -2; dy меньше равно; dy++) {
    if ( Math.abs(dx * dy) == 2){
    // Появляется еще один уровень вложенности
    // Еще один отступ
    // ...
    }
    }
    }
    Как и в операторе break, в continue можно определить метку, указывающую, какой включающий цикл
    следует продолжить.


    17.Одномерные массивы
    Под структурой данных в программировании понимается множество значений одного или разных типов,
    определенным образом размещенных в памяти компьютера. Структура данных, рассматриваемая как
    целое, снабжается именем, а для доступа к отдельным входящим в нее значениям определяется
    специальный синтаксис.


    Массив — это самая простая структура данных, которая представляет собой заданное количество
    значений одинакового типа — элементов массива, размещенных последовательно в ячейках памяти.
    Количество таких элементов называется размером массива, а тип элементов — типом массива. Ниже в
    качестве примеров будут использоваться массивы типа int, однако все сказанное применимо и к
    массивам других типов.

    Объявление и создание массивов. При объявлении массива, как и при объявлении переменной, нужно
    указать имя массива и его тип, например:

    int[] a;
    Квадратные скобки после имени типа указывают на то, что объявляется именно массив, а не простая
    переменная. Можно одновременно объявить несколько массивов:

    int [] a, b, c;
    Допустимо также объявление массивов в стиле языка C/C++, а именно с записью квадратных скобок
    после имени массива:

    int a[];
    В этом случае объявление одновременно нескольких массивов будет выглядеть более громоздко:

    int a[], b[], c[];
    Однако применение такого синтакиса позволяет одновременно объявить как массив, так и простую
    переменную:

    int a[], i;
    В отличие от переменной примитивного типа, например, целочисленной, объявления массива
    недостаточно для начала работы с ним. Следующим шагом является создание массива с заданием его
    размера. Создание массива осуществляется с помощью операции new и имеет следующий синтаксис:

    //ПСЕВДОКОД
    имя массива = new тип [размер]
    Здесь и далее в этом разделе квадратные скобки в примерах на псевдокоде являются элементом
    конструкции. Их писать нужно в любом случае.

    Например:

    a = new int [10];
    Объявление массива можно совместить с его созданием, используя следующий синтаксис:

    //ПСЕВДОКОД
    тип имя массива[] = new тип [размер]
    Например:

    int a[] = new int [10];
    При создании массива происходит его инициализация, то есть присваивание начальных значений
    элементам массива. По умолчанию компилятор инициализирует числовые массивы нулевыми значениями,
    символьные — нулевым символом (символом с кодом 0), логические — значением false.

    Имеется возможность инициализировать элементы массива другими значениями, добавив в оператор
    создания массива список выражений, заключенный в фигурные скобки:

    //ПСЕВДОКОД
    тип имя массива[] = new тип[] {список выражений};
    Например, если имеются ранее объявленные и инициализированные переменные x и y, то можно
    следующим образом создать и инициализировать массив a:

    int a[] = new int [] {3, 11, x, 2*x, y – x};
    При этом размер создаваемого массива не указывается, поскольку он устанавливается равным длине
    списка инициализации (в примере это 5). Более того, использование списка инициализации позволяет
    отказаться от операции new и создавать массив с использованием простого синтаксиса:

    тип имя массива[] = {список выражений};
    Например:

    int a[] = {3, 11, x, 2*x, y – x};
    После создания массива его размер сохраняется в свойстве length, которое рекомендуется
    использовать в различных алгоритмах обработки массивов. Обращение к этому свойству имеет
    синтаксис:

    //ПСЕВДОКОД
    имя массива.length
    Например, для массива a, объявленного в предыдущем примере, оператор

    System.out.println(a.length);
    выведет на экран значение 5.

    Доступ к элементам массива
    Элементы массива нумеруются, начиная с нулевого значения, и номер элемента называется его
    индексом. Таким образом, первому элементу массива соответствует значение индекса 0, второму —
    значение индекса 1, элементу с порядковым номером k — значение индекса k-1. Для доступа к
    отдельным элементам массива используется следующий синтаксис:

    //ПСЕВДОКОД
    имя массива[выражение целого типа]
    Значение выражения в квадратных скобках рассматривается как индекс элемента массива и поэтому
    должно иметь значение в диапазоне от 0 до length — 1 включительно.

    В случае, если в ходе выполнения программа пытается выйти за границы массива (обратиться к
    элементу массива с индексом вне диапазона от 0 до размерности массива минус 1), то возникнет
    ошибка — исключение ArrayIndexOutOfBoundsException. Поэтому необходимо внимательно отслеживать
    возможный диапазон значений, которые может принять индекс массива. Как сделать программу более
    устойчивой и обрабатывать возникающие по ходу выполнения программы исключения, более подробно
    будет рассмотрено в одной из тем второго модуля.


    18.Определение метода


    В процедурных языках (Си, Паскаль и другие) функцией называют участок кода, к которому можно
    обратиться из другой части программы. Удобно рассматривать функцию как черный ящик, на вход
    которого подаются входящие значения, а на выходе получаем результат — возвращаемые значения.
    Функция, не имеющая возвращаемых значений, в программировании называется процедурой.

    Примерами процедур могут являться функции ввода/вывода, а примерами функций — любые
    математические операции, например, sqrt(x) - это функция извлечения квадратного корня из числа
    x.

    Java полностью объектно-ориентированный язык, в нем все реализовано в классах, и потому в нем
    нет самостоятельных (глобальных) процедур и функций, они всегда определяются в некотором классе.
    В объектно-ориентированном программировании функции и процедуры, располагающиеся внутри класса,
    получили другое название — методы. Разница только в названии. В отношении Java можно употреблять
    слова «функция» и «процедура», но лучше говорить «метод, возвращающий значение» и «метод, не
    возвращающий значения».

    Методы определяются в классе, потому говорят: «у этого класса есть следующие методы» или «эти
    методы находятся в данном классе», или «этот метод из данного класса», или «этот метод определен
    в данном классе». Так же могут сказать, что «метод принадлежит классу».

    Чтобы определить метод в Java используют синтаксис:

    // Псевдокод
    [модификаторы] тип возвращаемого значения название_метода ([параметры]){
    тело метода
    }
    Модификаторы подробно рассматриваются во втором модуле. В коде они присутствуют не всегда (об
    этом говорит то, что в определении они указаны в квадратных скобках). Часто встречаются
    модификаторы public — это спецификация доступа означает возможность доступа к методу класса из
    других классов, и static — это ключевое слово говорит о том, что метод можно вызвать, не
    создавая объект. В первом модуле мы не создаем объектов кроме массивов, например, не создаем
    объект главного класса, в котором определен метод public static void main() (кстати, сам метод
    main() объявлен c модификатором static, потому что виртуальная машина его вызывает без создания
    объекта класса).

    Тип возвращаемого значения — это тип результата, который возвращает метод, например, метод
    класса Math, вычисляющий квадратный корень, имеет тип возвращаемого значения double.

    Название метода служит для того, чтобы к методу обращаться.

    Параметры: здесь в круглых скобках указывается список входных значений, параметров может и не
    быть.

    Тело метода: все, что находится между фигурными скобками, — это собственно код, который будет
    выполняться при вызове метода.

    Имя метода, также как и переменной:

    должно начинаться только с буквы;
    может состоять из любой последовательности строчных и прописных букв, но принято использовать
    только латинские;
    может содержать символы подчеркивания (_) и знака доллара ($);
    должно учитывать регистр (например, имена MyMethod и myMethod компилятор посчитает разными
    именами);
    не должно совпадать с именами операторов и зарезервированных слов самого языка Java;
    не должно совпадать с именами clone, equals, finalize, getClass, hashCode, notify, notifyAll,
    toString, wait. Если только вы не хотите явно переопределить действия этих методов.
    Методы clone(), equals(), finalize(), getClass(), hashCode(), notify(), notifyAll(), toString(),
    wait() объявлены в классе Object, главном класса Java, от которого наследуются все другие
    классы. Поэтому, даже если ваш класс явно не наследуется от другого класса, неявно он является
    подклассом Object, а значит имеет все эти методы в любом случае.

    Правилом хорошего тона считается давать методу такое имя, по которому можно легко догадаться, в
    чем его назначение. Обычно в названии метода используется глагол. Плохое имя для метода,
    определяющего цену товара p(), лучше price(), совсем хорошо getPrice(). В литературе обычно
    пишут имена методов со скобками, чтобы было видно, что это именно метод, а не переменная. При
    этом скобки оставляют пустыми, даже если функция принимает параметры.


    19. Параметры метода
    Параметры — это входящие значения, которые передаются в метод. В примере 1.17 в скобках мы
    указали после имени метода int x, а во втором варианте int[] arr. И в том, и другом случае это
    параметры, они передаются в метод для того, чтобы использовать их для выполнения операций внутри
    метода, фактически обрабатывать переданные значения.

    Как и при определении переменных, у параметров сначала пишется тип, а затем имя параметра.

    Если параметров несколько, то записываем их через запятую. Тип необходимо указывать у каждого
    параметра.

    Пусть у нас объявлены две переменных x и y — координаты персонажа в игре.

    В качестве примера определим метод Walk(), смещающий его на dx, dy:

    static int x, y;
    public static void Walk(int dx, int dy){
    x += dx;
    y += dy;
    }
    В скобках определены через запятую целые параметры: int dx, int dy. Этот метод меняет переменные
    x и y, они объявлены на уровне класса и доступны из любого метода.

    Параметров может быть сколько угодно много. Так же допустимо отсутствие параметров.


    20.Возвращаемое значение


    В предыдущих примерах перед именем метода мы задавали тип возвращаемого значения void.

    В таком применении void — это обозначение того, что метод (функция) не возвращает значение.

    Если нужна функция, а не процедура, то вместо void нужно поставить тип возвращаемого значения.
    Это означает, что метод должен обязательно вернуть результат и он должен быть совместимым с
    указанным типом.

    В Java, как и во многих языках, чтобы вернуть из метода значение, используют оператор return.

    Возникает вопрос, зачем возвращать результат из метода через оператор return?

    Метод в такой форме позволит нам в вызывающей функции самим решить, что делать с результатом:
    вывести на экран, использовать в арифметических выражениях и так далее. Такой способ реализации
    является более правильным, потому что придает методу большую универсальность в использовании.
    Например, никому не нужна была бы функция, которая вычисляла значение синуса и сразу выводила бы
    вычисленное значение на экран. Благодаря тому, что функция sin() возвращает значение, ее можно
    использовать и в программировании графических спецэффектов, и в математических пакетах.

    Изменим предыдущий пример обработки массива так, чтобы результат не выводился на экран, а
    возвращался.

    public class MyProgram {

    // Метод вычисления максимума или минимума
    public static int getTopOfArray(int[] arr, int what) {
    int top = arr[0];
    for (int i = 0; i меньше равно arr.length - 1; i++) {
    if (what == 1) {
    if (arr[i] > top) {
    top = arr[i];
    }
    } else {
    if (arr[i] меньше top) {
    top = arr[i];
    }
    }
    }
    return top; // возвращение результата
    }

    public static void main(String[] args) {
    int[] a = { 1, 5, 3, 7, 2 }; // задаем массив
    //вызываем метод
    System.out.println("Результат: " + getTopOfArray(a, 1));
    }
    }
    Что происходит в точке вызова метода в тексте программы?

    В исходном методе компилятор доходит до вызова второго метода и выполняет его в новой выделенной
    области памяти, а когда там доходит до оператора return, то помещает указанный в операторе
    результат в место вызова в исходном методе. Второй метод завершает свою работу и выделенная под
    его выполнение область памяти освобождается.

    Для того чтобы компилятор знал, куда возвращаться после выполнения очередной функции (метода), в
    программировании реализован механизм, который называется стек вызовов. Мы вернемся к этому
    вопросу при изучении материалов по теме «Рекурсия».


    21. Области видимости переменной
    В современном мире очень редко всю программу пишет один человек. Даже программист-одиночка
    использует библиотеки, фрагменты кода, написанные другими людьми. При этом естественно, имена
    переменных, функций, классов и других сущностей часто совпадают. Для того чтобы избежать
    конфликта имен в методах из разных частей кода, используются разные области видимости.

    Рассмотрим виды переменных на их уровнях.

    Глобальные переменные. В Java это переменные, объявленные в классе вне всякого метода. Значение
    таких переменных можно узнать или изменить в любом методе класса.

    Например,

    class Physics{
    static void printG(){
    System.out.println("G = " + G);
    }
    static final double G = 6.6720e-10;
    /*...*/
    }
    Здесь G — константа, которая видна в любом методе (неважно, что она объявлена ниже функции
    printG().

    Константа G объявлена с модификатором static, поэтому является по-настоящему глобальной, ее
    можно использовать и в других классах по имени класса, Physics. G.

    Локальные переменные. Это переменные, значения которых могут быть прочитаны или изменены только
    в месте их инициализации.

    Сами области видимости можно классифицировать следующим образом:

    Области класса.
    Области метода.
    Область блока.
    Переменные, объявленные в области класса, видны во всех методах класса. Переменные уровня класса
    инициализируются по умолчанию: числовые переменные получают нулевое значение, логические —
    значение false. При объявлении в блоке локальной переменной с тем же именем к переменным класса
    обращаются с указанием имени класса как показано в примере выше: Physics. G.

    Эта область будет подробно рассмотрена во втором модуле.

    Кроме входящих параметров можно инициализировать свои собственные переменные, которые называют
    локальными. Они существуют только в пределах своего метода, где были созданы, и извне, напрямую
    мы не можем получить их значения.

    Область блока уже обсуждалась ранее. Блоком внутри метода является конструкция, ограничивающая
    часть метода фигурными скобками и имеющая свои собственные локальные переменные. К блоковым
    конструкциям относятся ветвления, циклы и сами блоки непосредственно. Отсюда можно определить
    правило: переменные, определенные внутри блока фигурных скобок, видны всем на этом уровне и во
    всех вложенных блоках.

    В традиционном подходе для передачи/возвращения значений в/из функции нужно использовать
    механизм параметров и возврат через return, а еще с большой осторожностью глобальные переменные.
    Однако объектно-ориентированные языки, такие, как Java, дают и другие способы, о которых мы
    будем говорить в следующем модуле.


    22.Многомерные массивы
    Введение
    Массив, который в качестве своих элементов содержит другие массивы, называется многомерным
    массивом.

    Очень часто в программировании используют таблицы — двумерные массивы. Реже массивы с большим
    количеством измерений. Принцип работы с такими структурами данных в Java одинаков и очень похож
    на работу с «обычными» одномерными линейными массивами.

    Массив может состоять не только из элементов какого-то встроенного типа (int, double, char и
    пр.), но и, в том числе, из объектов какого-то существующего класса и даже из других массивов.

    Можно считать, что в Java есть только одномерные массивы.


    А двумерные — это фактически одномерный массив одномерных массивов. Трехмерные — это массив
    массивов, каждой ячейкой которого является одномерный массив. И так далее.

    При работе с многомерными массивами надо научиться решать три задачи:

    выделять память нужного размера под массив;
    записывать данные в нужную ячейку;
    читать данные из ячейки.
    Чаще всего используются двумерные массивы. Такие массивы можно легко представить в виде матрицы.
    Каждая строка которой является обычным одномерным массивом, а объединение всех строк — двумерным
    массивом, в каждом элементе которого хранится ссылка на какую-то ячейку матрицы. Например, на
    схеме выше приведен пример двумерного массива, у которого N строк и каждая строка ссылается на
    одномерный массив из M элементов. Таким образом, получается задан массив, например,
    matrix[N][M].

    Нумерация элементов массива начинается с нуля. Поэтому при обращении к последнему элемент
    массива имеет индекс N, а N - 1.

    Например, к последнему элементу на рисунке можно обратиться matrix[N-1][M-1]. Если N=7, а M=10,
    то последний элемент будет matrix[6][9].

    Трехмерный массив можно представить себе как набор матриц, каждую из которых можно записать,
    например, на библиотечной карточке. Тогда, чтобы добраться до конкретного числа, сначала нужно
    указать номер карточки (первый индекс трехмерного массива), потом указать номер строки (второй
    индекс массива) и только затем номер элемента в строке (третий индекс).

    Соответственно, для того чтобы обратиться к элементу N-мерного массива, нужно указать N
    индексов.


    23.Создание многомерных массивов и обращение к их элементам
    Для того чтобы использовать массив, нам необходимо объявить и инициализировать его. Объявление
    массива можно совместить с его созданием, используя следующий синтаксис:

    //ПСЕВДОКОД
    тип_массива[][] имя_массива =
    new тип_массива [размер "по вертикали"][размер "по горизонали"];
    Сначала указывается количество строк, а потом столбцов.

    Так же при обращении к элементам: сначала строка, потом столбец.

    Например, код:

    char[][] graph = new char[10][15];
    создаст массив graph из десяти строк и пятнадцати столбцов.

    Объявить массив без создания можно так:

    //ПСЕВДОКОД
    тип массива [][] имя массива;
    Например:

    int[] A1; // Обычный, одномерный массив целых
    int[][] A2; // Двумерный массив целых
    double[][][] A3; // Трёхмерный массив вещественных
    int[][][][][] A5; // Пятимерный массив целых
    И потом его нужно не забыть инициализировать.

    Например:

    A2 = new int[5][7]
    При создании массива часто сразу инициализируют его, например:

    int[][] А2 = new int[5][7]; // Матрица из 5-и строк и 7-и столбцов
    При создании массива происходит его инициализация, присваивание начальных значений элементам
    массива. По умолчанию компилятор инициализирует числовые массивы нулевыми значениями, символьные
    — нулевым символом (символом с кодом 0 (\0), логические — значением false. Имеется возможность
    инициализировать элементы массива другими значениями, добавив в оператор создания массива список
    выражений, заключенный в фигурные скобки:

    // Псевдокод
    тип массива[][] имя массива = new тип массива[][] {список выражений};
    Мы можем создать массив, явно указав его элементы. Например, так:

    int[][] array = { { 3, 6, 5, 7 }, { 3, 2, 1, 6 }, { 7, 8, 9, 0 } };
    И результатом будет заполненный массив размером 3 х 4.

    После создания массива его размер сохраняется в свойстве length, которое рекомендуется
    использовать в различных алгоритмах обработки массивов. Обращение к этому свойству имеет
    синтаксис:

    // Псевдокод
    имя массива.length
    out.println(array.length);
    Для двумерного массива — это количество строк.

    А для определения размера строки используется следующее обращение array[i].length.

    Доступ к ячейкам массива
    Для доступа к отдельным элементам массива используется следующий синтаксис:

    // Псевдокод
    имя_массива[выражение целого типа][выражение целого типа];
    Например:

    int x = array[0][1];
    A2[3][x - 1]++;
    Значение выражения в квадратных скобках рассматривается как индекс элемента массива и поэтому
    должно иметь значение в диапазоне от 0 до length – 1 включительно.

    Выход за границы этого диапазона приводит к ошибке времени выполнения (выбрасывается исключение
    ArrayIndexOutOfBoundsException).


    24. Двумерный массив


    Чаще всего используются двумерные массивы с равным количеством элементов в каждой строке. Для
    обработки двумерных массивов используются два вложенных друг в друга цикла с разными счетчиками.
    Матрица — это прямоугольная таблица однотипных элементов или, другими словами, это массив
    одномерных массивов. Матрицы часто применяются для хранения графов, описывающих, например,
    транспортные сети.

    Говоря о квадратной матрице, мы сталкиваемся с понятиями:


    элементы главной диагонали (i=j);
    элементы побочной диагонали (i+j=n−1, n — количество строк или столбцов квадратной матрицы);
    элементы ниже главной диагонали (i>j);
    элементы выше главной диагонали (i меньше j);
    элементы ниже побочной диагонали (i+j>n−1);
    элементы выше побочной диагонали (i+j меньше n−1).
    Элементы главной диагонали на рисунке 1.11 (15, 16, 3, -1, 5), а элементы побочной диагонали
    (-9, -8, 3, -7, 20).
    Всю работу с массивами можно разделить на несколько блоков:
    -Блок ввода данных массива
    -Блок обработки полученных данных массива
    -Блок вывода данных массива


    25. Трехмерный массив


    Четырехмерные и пятимерные массивы мы рассматривать не будем, так как они сложны для восприятия.
    Обработка данных массивов сводится все к тем же вложенным циклам. Для каждого уровня массива
    свой цикл обработки.

    Остановимся на трехмерном массиве. Трехмерный массив — это массив двумерных массивов. Работа с
    трехмерным массивом похожа на работу с двумерным массивом, только используется не два, а три
    цикла для работы с индексами элемента массива.
</string>


<string name="large_text2">
       Вывод звключается в том, что язык программирования Java не такой уж и трудный, и выучить его можно. Язык программирования Java - это полностью объектно-ориентированный язык, который в отношении синтаксиса многое унаследовал от С++. Конечно, преимущества Java далеко не исчерпываются межплатформенностью. Язык Java в синтаксическом отношении проще и логичнее, чем С++. Java как платформа предоставляет в распоряжение программистов большое количество библиотек (пакетов), в которых содержится большое количество описаний классов и интерфейсов на все случаи жизни. С их помощью можно создавать стопроцентные приложения Java с возможностью обращения к базам данных, поддержкой передачи почтовых сообщений, с клиентской частью, которой необходим web-браузер, или, наоборот, с клиентской частью, обладающей изощренным интерфейсом.

Java - это очень элегантный и красивый язык. Однако при его использовании проблем также избежать не удастся. Одна из серьезных проблем заключается в том, что при создании сложного приложения на Java вам придется использовать только этот язык для создания всех частей этого приложения. В Java предусмотрено не так уж много средств для межъязыкового взаимодействия (что понятно ввиду предназначения Java быть единым многоцелевым языком программирования). В реальном мире существуют миллионы строк готового кода, которые хотелось бы интегрировать с новыми приложениями на Java. Однако это сделать очень трудно.


    </string><string name="action_settings">Settings</string><string name="title_activity_scrolling2">ScrollingActivity</string><string name="title_activity_scrolling3">ScrollingActivity</string><string name="title_activity_scrolling4">ScrollingActivity</string><string name="title_activity_scrolling5">ScrollingActivity</string><string name="title_activity_scrolling6">ScrollingActivity</string><string name="title_activity_settings">SettingsActivity</string>

    <!-- Preference Titles -->
<string name="messages_header">Messages</string><string name="sync_header">Sync</string>

    <!-- Messages Preferences -->
<string name="signature_title">Your signature</string><string name="reply_title">Default reply action</string>

    <!-- Sync Preferences -->
<string name="sync_title">Sync email periodically</string><string name="attachment_title">Download incoming attachments</string><string name="attachment_summary_on">Automatically download attachments for incoming emails
    </string><string name="attachment_summary_off">Only download attachments when manually requested</string><string name="title_activity_scrolling7">ScrollingActivity</string><string name="title_activity_scrolling8">ScrollingActivity</string><string name="title_activity_scrolling9">ScrollingActivity</string></resources>